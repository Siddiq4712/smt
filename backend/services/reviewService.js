// backend/services/reviewService.js
import Review from "../models/Review.js";
import User from "../models/User.js";
import { Op } from 'sequelize';
import { getOmdbMovie } from "../utils/omdbApi.js";
import { calculateReviewHash } from "../utils/hasher.js"; // <--- NEW IMPORT

// Helper function to find if a user has already reviewed a specific movie
export const findExistingReviewByUserAndMovie = async (userId, movieTitle) => {
  return await Review.findOne({
    where: {
      userId,
      movieTitle: {
        [Op.like]: movieTitle
      }
    },
    include: { model: User, attributes: ["id", "username", "email"] }
  });
};

// Add a new review - MODIFIED for hash-chaining
export const createReview = async (userId, movieTitle, reviewText, rating) => {
  if (!movieTitle || !reviewText || !rating) {
    throw new Error("All fields are required");
  }

  // --- OMDB Validation ---
  const omdbMovie = await getOmdbMovie(movieTitle);
  if (!omdbMovie) {
    throw new Error(`"${movieTitle}" is not a valid movie title found on OMDB. Please select a valid movie.`);
  }
  const validatedMovieTitle = omdbMovie.Title;
  // --- End OMDB Validation ---

  // Check if the user has already reviewed this movie (using the validated title)
  const existingReview = await findExistingReviewByUserAndMovie(userId, validatedMovieTitle);
  if (existingReview) {
    throw new Error(`You have already reviewed "${validatedMovieTitle}". Please edit your existing review.`);
  }

  // --- BLOCKCHAIN-INSPIRED LOGIC: Get previous block hash ---
  let previousBlockHash = '0'; // Default for the first review (genesis block)
  const latestReview = await Review.findOne({
      order: [['createdAt', 'DESC']],
      attributes: ['originalBlockHash'], // Only fetch the hash
  });

  if (latestReview) {
      previousBlockHash = latestReview.originalBlockHash;
  }
  // --- END BLOCKCHAIN-INSPIRED LOGIC ---

  // Create the review record first to get its ID and createdAt timestamp
  // These are important for creating a truly unique and verifiable hash
  const newReview = await Review.create({
    movieTitle: validatedMovieTitle,
    reviewText,
    rating,
    userId,
    // Temporary originalBlockHash & previousBlockHash will be overwritten
    // We need createdAt to be generated by DB before hashing actual block data
    originalBlockHash: 'pending',
    previousBlockHash: previousBlockHash,
  });

  // --- BLOCKCHAIN-INSPIRED LOGIC: Calculate current block hash ---
  // Data for the immutable block, including its unique ID and timestamp
  const blockData = {
      id: newReview.id, // Use generated ID for uniqueness
      movieTitle: newReview.movieTitle,
      reviewText: newReview.reviewText, // Use original text
      rating: newReview.rating,       // Use original rating
      userId: newReview.userId,
      createdAt: newReview.createdAt, // Use DB generated timestamp
      previousBlockHash: newReview.previousBlockHash, // Link to previous block
  };
  const originalBlockHash = calculateReviewHash(blockData);

  // Update the review with its calculated originalBlockHash
  newReview.originalBlockHash = originalBlockHash;
  await newReview.save();
  // --- END BLOCKCHAIN-INSPIRED LOGIC ---

  const createdReviewWithUser = await Review.findByPk(newReview.id, {
    include: { model: User, attributes: ["id", "username", "email"] }
  });

  return createdReviewWithUser;
};

// Get all reviews with optional filtering, sorting, and searching
export const fetchReviews = async (filterOptions = {}) => {
  const { rating, sortBy, searchQuery } = filterOptions;

  let where = {};
  if (rating && rating !== 'all') {
    const parsedRating = parseInt(rating, 10);
    if (!isNaN(parsedRating) && parsedRating >= 1 && parsedRating <= 5) {
      where.rating = parsedRating;
    }
  }

  if (searchQuery) {
    where.movieTitle = {
      [Op.like]: `%${searchQuery}%`
    };
  }

  let order = [['createdAt', 'DESC']];
  if (sortBy === 'highest_rating') {
    order = [['rating', 'DESC'], ['createdAt', 'DESC']];
  } else if (sortBy === 'lowest_rating') {
    order = [['rating', 'ASC'], ['createdAt', 'DESC']];
  }

  const reviews = await Review.findAll({
    where,
    include: { model: User, attributes: ["id", "username", "email"] },
    order,
  });
  return reviews;
};

// Fetch reviews for a specific user
export const fetchUserReviews = async (userId) => {
  const reviews = await Review.findAll({
    where: { userId },
    include: { model: User, attributes: ["id", "username", "email"] },
    order: [["createdAt", "DESC"]],
  });
  return reviews;
};

// Update an existing review - IMPORTANT: originalBlockHash and previousBlockHash are NOT updated
export const updateReview = async (reviewId, userId, reviewText, rating) => {
  const review = await Review.findByPk(reviewId);

  if (!review) {
    throw new Error("Review not found");
  }

  if (review.userId !== userId) {
    throw new Error("Not authorized to update this review");
  }

  if (!reviewText || !rating) {
    throw new Error("Review text and rating are required");
  }

  // --- BLOCKCHAIN-INSPIRED LOGIC: originalBlockHash and previousBlockHash are NOT updated ---
  // They represent the immutable initial block. Only mutable fields are updated.
  review.reviewText = reviewText;
  review.rating = rating;
  await review.save();

  const updatedReviewWithUser = await Review.findByPk(review.id, {
    include: { model: User, attributes: ["id", "username", "email"] }
  });

  return updatedReviewWithUser;
};

// Delete a review (No change needed)
export const deleteReview = async (reviewId, userId) => {
  const review = await Review.findByPk(reviewId);

  if (!review) {
    throw new Error("Review not found");
  }

  if (review.userId !== userId) {
    throw new Error("Not authorized to delete this review");
  }

  await review.destroy();
  return { message: "Review deleted successfully" };
};
